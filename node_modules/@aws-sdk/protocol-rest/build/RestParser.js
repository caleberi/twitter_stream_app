"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var is_array_buffer_1 = require("@aws-sdk/is-array-buffer");
var protocol_timestamp_1 = require("@aws-sdk/protocol-timestamp");
var response_metadata_extractor_1 = require("@aws-sdk/response-metadata-extractor");
var RestParser = /** @class */ (function () {
    function RestParser(bodyParser, bodyCollector, parseServiceException, utf8Encoder, base64Decoder) {
        this.bodyParser = bodyParser;
        this.bodyCollector = bodyCollector;
        this.parseServiceException = parseServiceException;
        this.utf8Encoder = utf8Encoder;
        this.base64Decoder = base64Decoder;
    }
    RestParser.prototype.parse = function (operation, input) {
        var _this = this;
        var output = {};
        var responseHeaders = input.headers;
        output.$metadata = response_metadata_extractor_1.extractMetadata(input);
        if (this.responseIsSuccessful(input.statusCode)) {
            this.parseHeaders(output, responseHeaders, operation.output);
            this.parseStatusCode(output, input.statusCode, operation.output);
            return this.parseBody(output, operation.output, input);
        }
        else {
            return this.resolveBodyString(input.body).then(function (body) {
                throw _this.parseServiceException(operation, tslib_1.__assign({}, input, { body: body }), _this.bodyParser);
            });
        }
    };
    RestParser.prototype.parseBody = function (output, member, response) {
        var _this = this;
        // determine if the member references a payload member
        var shape = member.shape;
        var body = response.body;
        var payloadName = shape.payload;
        if (payloadName) {
            var payloadMember_1 = shape.members[payloadName];
            var payloadShape_1 = payloadMember_1.shape;
            if (payloadShape_1.type === "blob") {
                if (payloadMember_1.streaming || payloadShape_1.streaming) {
                    output[payloadName] = body;
                    return Promise.resolve(output);
                }
                // non-streaming blobs should always be byte arrays
                return this.resolveBody(body).then(function (buffer) {
                    output[payloadName] = buffer;
                    return output;
                });
            }
            else {
                return this.resolveBodyString(body).then(function (body) {
                    if (payloadShape_1.type === "structure" ||
                        payloadShape_1.type === "list" ||
                        payloadShape_1.type === "map") {
                        output[payloadName] = _this.bodyParser.parse(payloadMember_1, body);
                    }
                    else {
                        output[payloadName] = _this.parseScalarBody(payloadShape_1, body);
                    }
                    return output;
                });
            }
        }
        else {
            return this.resolveBodyString(body).then(function (body) {
                var e_1, _a;
                if (body.length > 0) {
                    var parsedBody = _this.bodyParser.parse(member, body);
                    try {
                        for (var _b = tslib_1.__values(Object.keys(parsedBody)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var key = _c.value;
                            output[key] = parsedBody[key];
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                return Promise.resolve(output);
            });
        }
    };
    RestParser.prototype.parseHeaders = function (output, inputHeaders, member) {
        var e_2, _a, e_3, _b, e_4, _c;
        if (member.shape.type !== "structure") {
            return;
        }
        var lowerInputHeaders = {};
        try {
            // transform response headers into lowercase for easier comparisons
            for (var _d = tslib_1.__values(Object.keys(inputHeaders)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var header = _e.value;
                lowerInputHeaders[header.toLowerCase()] = inputHeaders[header];
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var members = member.shape.members;
        try {
            for (var _f = tslib_1.__values(Object.keys(members)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var memberName = _g.value;
                var member_1 = members[memberName];
                var location = member_1.location, _h = member_1.locationName, locationName = _h === void 0 ? memberName : _h, memberShape = member_1.shape;
                var hasLocationName = Boolean(member_1.locationName);
                if (location !== "header" && location !== "headers") {
                    continue;
                }
                var ruleHeaderName = locationName.toLowerCase();
                var inputHeaderValue = lowerInputHeaders[ruleHeaderName];
                if (memberShape.type === "map") {
                    output[memberName] = {};
                    var regex = new RegExp("^" + locationName + "(.+)", "i");
                    try {
                        // iterate over each header
                        for (var _j = tslib_1.__values(Object.keys(inputHeaders)), _k = _j.next(); !_k.done; _k = _j.next()) {
                            var header = _k.value;
                            var result = header.match(regex);
                            if (result) {
                                output[memberName][result[1]] = inputHeaders[header];
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
                else {
                    if (typeof inputHeaderValue !== "undefined") {
                        output[memberName] = this.parseScalarHeader(memberShape, inputHeaderValue);
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    RestParser.prototype.parseScalarBody = function (shape, input) {
        switch (shape.type) {
            case "timestamp":
                return protocol_timestamp_1.toDate(input);
            case "string":
                if (typeof input === "string") {
                    return input;
                }
                else {
                    return this.utf8Encoder(input);
                }
            case "boolean":
                return typeof input === "boolean" ? input : input === "true";
            case "integer":
                return parseInt(input, 10);
            case "float":
                return parseFloat(input);
        }
    };
    RestParser.prototype.parseScalarHeader = function (shape, input) {
        switch (shape.type) {
            case "timestamp":
                return protocol_timestamp_1.toDate(input);
            case "string":
                return shape.jsonValue
                    ? JSON.parse(this.utf8Encoder(this.base64Decoder(input)))
                    : input;
            case "boolean":
                return input === "true";
            case "integer":
                return parseInt(input, 10);
            case "float":
                return parseFloat(input);
            case "blob":
                return this.base64Decoder(input);
        }
    };
    RestParser.prototype.parseStatusCode = function (output, statusCode, member) {
        var e_5, _a;
        if (!statusCode) {
            return;
        }
        var shape = member.shape;
        var members = shape.members;
        try {
            for (var _b = tslib_1.__values(Object.keys(members)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var memberName = _c.value;
                var member_2 = members[memberName];
                if (member_2.location === "statusCode") {
                    var name = member_2.locationName || memberName;
                    output[name] = statusCode;
                    return;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    RestParser.prototype.resolveBody = function (body) {
        if (body === void 0) { body = ""; }
        if (typeof body === "string") {
            return Promise.resolve(body);
        }
        var bufferPromise;
        if (ArrayBuffer.isView(body)) {
            bufferPromise = Promise.resolve(new Uint8Array(body.buffer, body.byteOffset, body.byteLength));
        }
        else if (is_array_buffer_1.isArrayBuffer(body)) {
            bufferPromise = Promise.resolve(new Uint8Array(body, 0, body.byteLength));
        }
        else {
            bufferPromise = this.bodyCollector(body);
        }
        return bufferPromise;
    };
    RestParser.prototype.resolveBodyString = function (body) {
        var _this = this;
        if (body === void 0) { body = ""; }
        return this.resolveBody(body).then(function (buffer) {
            return typeof buffer === "string" ? buffer : _this.utf8Encoder(buffer);
        });
    };
    RestParser.prototype.responseIsSuccessful = function (statusCode) {
        return statusCode < 300;
    };
    return RestParser;
}());
exports.RestParser = RestParser;
//# sourceMappingURL=RestParser.js.map