"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var protocol_timestamp_1 = require("@aws-sdk/protocol-timestamp");
var util_uri_escape_1 = require("@aws-sdk/util-uri-escape");
var is_iterable_1 = require("@aws-sdk/is-iterable");
var RestSerializer = /** @class */ (function () {
    function RestSerializer(endpoint, bodySerializer, base64Encoder, utf8Decoder) {
        this.endpoint = endpoint;
        this.bodySerializer = bodySerializer;
        this.base64Encoder = base64Encoder;
        this.utf8Decoder = utf8Decoder;
    }
    RestSerializer.prototype.serialize = function (operation, input) {
        var httpTrait = operation.http, inputModel = operation.input;
        var baseUri = this.endpoint.path + "/" + httpTrait.requestUri;
        // Depending on payload rules, body may be binary, or a string
        var body = this.serializeBody(operation, input);
        var serializedParts = this.serializeNonBody(inputModel.shape, input, baseUri);
        return tslib_1.__assign({}, this.endpoint, { body: body, headers: tslib_1.__assign({}, this.populateContentTypeHeader(operation, input), serializedParts.headers), method: httpTrait.method, query: serializedParts.query, path: serializedParts.uri });
    };
    RestSerializer.prototype.serializeBody = function (operation, input) {
        var inputModel = operation.input;
        var inputModelShape = inputModel.shape;
        var bodyMember = inputModel;
        var hasPayload = false;
        var memberName;
        var bodyInput = input;
        var method = operation.http.method;
        if (method === "GET" || method === "HEAD") {
            // GET and HEAD requests should not have a body
            return null;
        }
        var payloadName = inputModelShape.payload;
        if (payloadName) {
            hasPayload = true;
            bodyMember = inputModelShape.members[payloadName];
            memberName = bodyMember.locationName || payloadName;
            bodyInput = input[payloadName];
            // non-structure payloads should not be transformed
            if (bodyMember.shape.type !== "structure") {
                if (bodyInput === void 0 || bodyInput === null) {
                    return "";
                }
                return bodyInput;
            }
        }
        else {
            memberName = bodyMember.locationName;
        }
        return this.bodySerializer.build({
            hasPayload: hasPayload,
            input: bodyInput,
            member: bodyMember,
            memberName: memberName,
            operation: operation
        });
    };
    RestSerializer.prototype.serializeNonBody = function (shape, input, baseUri) {
        var e_1, _a;
        var headers = {};
        var query = {};
        // reduce consecutive slashes to a single slash
        var uri = baseUri.replace(/\/+/g, "/");
        // move existing query string params
        var uriParts = uri.split("?", 2);
        if (uriParts.length === 2) {
            this.parseQueryString(query, uriParts[1]);
            // remove query string from the URI since it has been processed
            uri = uriParts[0];
        }
        var members = shape.members;
        try {
            for (var _b = tslib_1.__values(Object.keys(members)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var memberName = _c.value;
                // check if input contains the member
                var inputValue = input[memberName];
                if (typeof inputValue === "undefined" || inputValue === null) {
                    continue;
                }
                var member = members[memberName];
                var location = member.location, _d = member.locationName, locationName = _d === void 0 ? memberName : _d;
                if (location === "header" || location === "headers") {
                    this.populateHeader(headers, member, locationName, inputValue);
                }
                else if (location === "uri") {
                    uri = this.populateUri(uri, locationName, inputValue);
                }
                else if (location === "querystring") {
                    this.populateQuery(query, member, locationName, inputValue);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return { headers: headers, query: query, uri: uri };
    };
    RestSerializer.prototype.populateQuery = function (query, member, name, input) {
        var e_2, _a, e_3, _b, e_4, _c;
        var shape = member.shape;
        if (shape.type === "list") {
            var values = [];
            if (is_iterable_1.isIterable(input)) {
                try {
                    for (var input_1 = tslib_1.__values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
                        var value = input_1_1.value;
                        values.push(String(value));
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                query[name] = values;
            }
            else {
                throw new Error("Unable to serialize value that is neither an array nor an" +
                    " iterable as a list");
            }
        }
        else if (shape.type === "map") {
            if (is_iterable_1.isIterable(input)) {
                try {
                    for (var input_2 = tslib_1.__values(input), input_2_1 = input_2.next(); !input_2_1.done; input_2_1 = input_2.next()) {
                        var _d = tslib_1.__read(input_2_1.value, 2), inputKey = _d[0], inputValue = _d[1];
                        this.populateQuery(query, shape.value, inputKey, inputValue);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (input_2_1 && !input_2_1.done && (_b = input_2.return)) _b.call(input_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
            else if (typeof input === "object" && input !== null) {
                try {
                    for (var _e = tslib_1.__values(Object.keys(input)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var inputKey = _f.value;
                        var inputValue = input[inputKey];
                        this.populateQuery(query, shape.value, inputKey, inputValue);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
        else if (shape.type === "timestamp") {
            query[name] = encodeURIComponent(String(protocol_timestamp_1.formatTimestamp(input, member.timestampFormat || shape.timestampFormat || "iso8601")));
        }
        else {
            query[name] = String(input);
        }
    };
    RestSerializer.prototype.populateUri = function (uri, name, input) {
        var regex = new RegExp("\\{" + name + "(\\+)?\\}");
        // using match instead of replace ends up being > twice as fast in V8
        var results = uri.match(regex);
        if (results) {
            var _a = tslib_1.__read(results, 2), fullMatch = _a[0], plus = _a[1];
            var index = results.index;
            var escapedInputValue = plus ? util_uri_escape_1.escapeUriPath(input) : util_uri_escape_1.escapeUri(input);
            uri =
                uri.substr(0, index) +
                    escapedInputValue +
                    uri.substr(index + fullMatch.length);
        }
        return uri;
    };
    RestSerializer.prototype.populateHeader = function (headers, member, name, input) {
        var e_5, _a, e_6, _b;
        var shape = member.shape;
        if (shape.type === "map") {
            if (is_iterable_1.isIterable(input)) {
                try {
                    for (var input_3 = tslib_1.__values(input), input_3_1 = input_3.next(); !input_3_1.done; input_3_1 = input_3.next()) {
                        var _c = tslib_1.__read(input_3_1.value, 2), inputKey = _c[0], inputValue = _c[1];
                        headers[name + inputKey] = String(inputValue);
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (input_3_1 && !input_3_1.done && (_a = input_3.return)) _a.call(input_3);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
            else if (typeof input === "object" && input !== null) {
                try {
                    for (var _d = tslib_1.__values(Object.keys(input)), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var inputKey = _e.value;
                        headers[name + inputKey] = String(input[inputKey]);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
        }
        else {
            switch (shape.type) {
                case "timestamp":
                    headers[name] = String(protocol_timestamp_1.formatTimestamp(input, member.timestampFormat || shape.timestampFormat || "rfc822"));
                    break;
                case "string":
                    headers[name] = shape.jsonValue
                        ? this.base64Encoder(this.utf8Decoder(JSON.stringify(input)))
                        : input;
                    break;
                case "integer":
                    headers[name] = parseInt(input).toString();
                    break;
                case "float":
                    headers[name] = parseFloat(input).toString();
                    break;
                case "blob": {
                    input = typeof input === "string" ? this.utf8Decoder(input) : input;
                    headers[name] = this.base64Encoder(input);
                    break;
                }
                default:
                    headers[name] = input.toString();
            }
        }
    };
    /**
     * Used to parse modeled paths that already include query strings.
     * Does not attempt to unescape values.
     * @param queryString
     */
    RestSerializer.prototype.parseQueryString = function (query, queryString) {
        var e_7, _a;
        try {
            // get individual keys
            for (var _b = tslib_1.__values(queryString.split("&")), _c = _b.next(); !_c.done; _c = _b.next()) {
                var keyValues = _c.value;
                var _d = tslib_1.__read(keyValues.split("="), 2), key = _d[0], value = _d[1];
                if (query.hasOwnProperty(key)) {
                    if (Array.isArray(query[key])) {
                        query[key].push(value);
                    }
                    else {
                        query[key] = [query[key], value];
                    }
                }
                else {
                    query[key] = value;
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    /**
     * @api private
     *
     * Add Content-Type header for rest-json protocol explicitly
     * If payload is supplied in input, the content-type should be set according to payload shape;
     * If payload is specified but not supplied in input, no content-type header is needed;
     * If there's no payload in input shape, set content-type as 'application/json';
     * @param operation
     * @param input
     */
    RestSerializer.prototype.populateContentTypeHeader = function (operation, input) {
        var contentTypeHeader = {};
        var inputShape = operation.input, protocol = operation.metadata.protocol;
        if (protocol !== "rest-json")
            return contentTypeHeader;
        if (typeof inputShape.shape.payload === "string") {
            var payloadMemberName = inputShape.shape.payload;
            var payloadMember = inputShape.shape.members[payloadMemberName];
            var payload = input[payloadMemberName];
            if (!payload)
                return contentTypeHeader;
            if (payloadMember.shape.type === "structure") {
                return { "Content-Type": "application/json" };
            }
            else if (payloadMember.shape.type === "blob") {
                return { "Content-Type": "binary/octet-stream" };
            }
        }
        else {
            return { "Content-Type": "application/json" };
        }
        return contentTypeHeader;
    };
    return RestSerializer;
}());
exports.RestSerializer = RestSerializer;
//# sourceMappingURL=RestSerializer.js.map