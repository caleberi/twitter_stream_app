"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var RemoteProviderInit_1 = require("./remoteProvider/RemoteProviderInit");
var httpGet_1 = require("./remoteProvider/httpGet");
var ImdsCredentials_1 = require("./remoteProvider/ImdsCredentials");
var retry_1 = require("./remoteProvider/retry");
var property_provider_1 = require("@aws-sdk/property-provider");
var url_1 = require("url");
exports.ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
exports.ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
exports.ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
/**
 * Creates a credential provider that will source credentials from the ECS
 * Container Metadata Service
 */
function fromContainerMetadata(init) {
    var _this = this;
    if (init === void 0) { init = {}; }
    var _a = RemoteProviderInit_1.providerConfigFromInit(init), timeout = _a.timeout, maxRetries = _a.maxRetries;
    return function () {
        return getCmdsUri().then(function (url) {
            return retry_1.retry(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var credsResponse, _a, _b;
                return tslib_1.__generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _b = (_a = JSON).parse;
                            return [4 /*yield*/, requestFromEcsImds(timeout, url)];
                        case 1:
                            credsResponse = _b.apply(_a, [_c.sent()]);
                            if (!ImdsCredentials_1.isImdsCredentials(credsResponse)) {
                                throw new property_provider_1.ProviderError("Invalid response received from instance metadata service.");
                            }
                            return [2 /*return*/, ImdsCredentials_1.fromImdsCredentials(credsResponse)];
                    }
                });
            }); }, maxRetries);
        });
    };
}
exports.fromContainerMetadata = fromContainerMetadata;
function requestFromEcsImds(timeout, options) {
    if (process.env[exports.ENV_CMDS_AUTH_TOKEN]) {
        var _a = options.headers, headers = _a === void 0 ? {} : _a;
        headers.Authorization = process.env[exports.ENV_CMDS_AUTH_TOKEN];
        options.headers = headers;
    }
    return httpGet_1.httpGet(tslib_1.__assign({}, options, { timeout: timeout })).then(function (buffer) { return buffer.toString(); });
}
var CMDS_IP = "169.254.170.2";
var GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true
};
var GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true
};
function getCmdsUri() {
    if (process.env[exports.ENV_CMDS_RELATIVE_URI]) {
        return Promise.resolve({
            hostname: CMDS_IP,
            path: process.env[exports.ENV_CMDS_RELATIVE_URI]
        });
    }
    if (process.env[exports.ENV_CMDS_FULL_URI]) {
        var parsed = url_1.parse(process.env[exports.ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
            return Promise.reject(new property_provider_1.ProviderError(parsed.hostname + " is not a valid container metadata service hostname", false));
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
            return Promise.reject(new property_provider_1.ProviderError(parsed.protocol + " is not a valid container metadata service protocol", false));
        }
        return Promise.resolve(tslib_1.__assign({}, parsed, { port: parsed.port ? parseInt(parsed.port, 10) : undefined }));
    }
    return Promise.reject(new property_provider_1.ProviderError("The container metadata credential provider cannot be used unless" +
        (" the " + exports.ENV_CMDS_RELATIVE_URI + " or " + exports.ENV_CMDS_FULL_URI + " environment") +
        " variable is set", false));
}
//# sourceMappingURL=fromContainerMetadata.js.map