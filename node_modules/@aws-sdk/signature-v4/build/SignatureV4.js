"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const credentialDerivation_1 = require("./credentialDerivation");
const getCanonicalHeaders_1 = require("./getCanonicalHeaders");
const getCanonicalQuery_1 = require("./getCanonicalQuery");
const getPayloadHash_1 = require("./getPayloadHash");
const prepareRequest_1 = require("./prepareRequest");
const moveHeadersToQuery_1 = require("./moveHeadersToQuery");
const constants_1 = require("./constants");
const protocol_timestamp_1 = require("@aws-sdk/protocol-timestamp");
const util_hex_encoding_1 = require("@aws-sdk/util-hex-encoding");
const hasHeader_1 = require("./hasHeader");
class SignatureV4 {
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        // default to true if applyChecksum isn't set
        this.applyChecksum =
            typeof applyChecksum === "boolean" ? applyChecksum : true;
        if (typeof region === "string") {
            const promisified = Promise.resolve(region);
            this.regionProvider = () => promisified;
        }
        else {
            this.regionProvider = region;
        }
        if (typeof credentials === "object") {
            const promisified = Promise.resolve(credentials);
            this.credentialProvider = () => promisified;
        }
        else {
            this.credentialProvider = credentials;
        }
    }
    async presignRequest(originalRequest, expiration, options = {}) {
        const [region, credentials] = await Promise.all([
            this.regionProvider(),
            this.credentialProvider()
        ]);
        const { signingDate = new Date(), unsignableHeaders } = options;
        const { longDate, shortDate } = formatDate(signingDate);
        const ttl = getTtl(signingDate, expiration);
        if (ttl > constants_1.MAX_PRESIGNED_TTL) {
            return Promise.reject("Signature version 4 presigned URLs" +
                " must have an expiration date less than one week in" +
                " the future");
        }
        const scope = credentialDerivation_1.createScope(shortDate, region, this.service);
        const request = moveHeadersToQuery_1.moveHeadersToQuery(prepareRequest_1.prepareRequest(originalRequest));
        if (credentials.sessionToken) {
            request.query[constants_1.TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[constants_1.ALGORITHM_QUERY_PARAM] = constants_1.ALGORITHM_IDENTIFIER;
        request.query[constants_1.CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[constants_1.AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[constants_1.EXPIRES_QUERY_PARAM] = ttl.toString(10);
        const canonicalHeaders = getCanonicalHeaders_1.getCanonicalHeaders(request, unsignableHeaders);
        request.query[constants_1.SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request.query[constants_1.SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash_1.getPayloadHash(originalRequest, this.sha256)));
        return request;
    }
    async sign(toSign, _a = {}) {
        var { signingDate = new Date() } = _a, options = tslib_1.__rest(_a, ["signingDate"]);
        const [region, credentials] = await Promise.all([
            this.regionProvider(),
            this.credentialProvider()
        ]);
        if (typeof toSign === "string") {
            return this.signString(toSign, signingDate, region, credentials);
        }
        else {
            const { unsignableHeaders } = options;
            return this.signRequest(toSign, signingDate, region, credentials, unsignableHeaders);
        }
    }
    async signString(stringToSign, signingDate, region, credentials) {
        const { shortDate } = formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate));
        hash.update(stringToSign);
        return util_hex_encoding_1.toHex(await hash.digest());
    }
    async signRequest(originalRequest, signingDate, region, credentials, unsignableHeaders) {
        const request = prepareRequest_1.prepareRequest(originalRequest);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = credentialDerivation_1.createScope(shortDate, region, this.service);
        request.headers[constants_1.AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
            request.headers[constants_1.TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await getPayloadHash_1.getPayloadHash(request, this.sha256);
        if (!hasHeader_1.hasHeader(constants_1.SHA256_HEADER, request.headers) && this.applyChecksum) {
            request.headers[constants_1.SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders_1.getCanonicalHeaders(request, unsignableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
        request.headers[constants_1.AUTH_HEADER] =
            `${constants_1.ALGORITHM_IDENTIFIER} ` +
                `Credential=${credentials.accessKeyId}/${scope}, ` +
                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +
                `Signature=${signature}`;
        return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery_1.getCanonicalQuery(request)}
${sortedHeaders.map(name => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash = new this.sha256();
        hash.update(canonicalRequest);
        const hashedRequest = await hash.digest();
        return `${constants_1.ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${util_hex_encoding_1.toHex(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
            const doubleEncoded = encodeURIComponent(path.replace(/^\//, ""));
            return `/${doubleEncoded.replace(/%2F/g, "/")}`;
        }
        return path;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash = new this.sha256(await keyPromise);
        hash.update(stringToSign);
        return util_hex_encoding_1.toHex(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate) {
        return credentialDerivation_1.getSigningKey(this.sha256, credentials, shortDate, region, this.service);
    }
}
exports.SignatureV4 = SignatureV4;
function formatDate(now) {
    const longDate = protocol_timestamp_1.iso8601(now).replace(/[\-:]/g, "");
    return {
        longDate,
        shortDate: longDate.substr(0, 8)
    };
}
function getCanonicalHeaderList(headers) {
    return Object.keys(headers)
        .sort()
        .join(";");
}
function getTtl(start, expiration) {
    return Math.floor((protocol_timestamp_1.toDate(expiration).valueOf() - protocol_timestamp_1.toDate(start).valueOf()) / 1000);
}
//# sourceMappingURL=SignatureV4.js.map