import * as tslib_1 from "tslib";
import { createScope, getSigningKey } from "./credentialDerivation";
import { getCanonicalHeaders } from "./getCanonicalHeaders";
import { getCanonicalQuery } from "./getCanonicalQuery";
import { getPayloadHash } from "./getPayloadHash";
import { prepareRequest } from "./prepareRequest";
import { moveHeadersToQuery } from "./moveHeadersToQuery";
import { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from "./constants";
import { iso8601, toDate } from "@aws-sdk/protocol-timestamp";
import { toHex } from "@aws-sdk/util-hex-encoding";
import { hasHeader } from "./hasHeader";
var SignatureV4 = /** @class */ (function () {
    function SignatureV4(_a) {
        var applyChecksum = _a.applyChecksum, credentials = _a.credentials, region = _a.region, service = _a.service, sha256 = _a.sha256, _b = _a.uriEscapePath, uriEscapePath = _b === void 0 ? true : _b;
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        // default to true if applyChecksum isn't set
        this.applyChecksum =
            typeof applyChecksum === "boolean" ? applyChecksum : true;
        if (typeof region === "string") {
            var promisified_1 = Promise.resolve(region);
            this.regionProvider = function () { return promisified_1; };
        }
        else {
            this.regionProvider = region;
        }
        if (typeof credentials === "object") {
            var promisified_2 = Promise.resolve(credentials);
            this.credentialProvider = function () { return promisified_2; };
        }
        else {
            this.credentialProvider = credentials;
        }
    }
    SignatureV4.prototype.presignRequest = function (originalRequest, expiration, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, region, credentials, _b, signingDate, unsignableHeaders, _c, longDate, shortDate, ttl, scope, request, canonicalHeaders, _d, _e, _f, _g, _h, _j;
            return tslib_1.__generator(this, function (_k) {
                switch (_k.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.regionProvider(),
                            this.credentialProvider()
                        ])];
                    case 1:
                        _a = _k.sent(), region = _a[0], credentials = _a[1];
                        _b = options.signingDate, signingDate = _b === void 0 ? new Date() : _b, unsignableHeaders = options.unsignableHeaders;
                        _c = formatDate(signingDate), longDate = _c.longDate, shortDate = _c.shortDate;
                        ttl = getTtl(signingDate, expiration);
                        if (ttl > MAX_PRESIGNED_TTL) {
                            return [2 /*return*/, Promise.reject("Signature version 4 presigned URLs" +
                                    " must have an expiration date less than one week in" +
                                    " the future")];
                        }
                        scope = createScope(shortDate, region, this.service);
                        request = moveHeadersToQuery(prepareRequest(originalRequest));
                        if (credentials.sessionToken) {
                            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
                        }
                        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
                        request.query[CREDENTIAL_QUERY_PARAM] = credentials.accessKeyId + "/" + scope;
                        request.query[AMZ_DATE_QUERY_PARAM] = longDate;
                        request.query[EXPIRES_QUERY_PARAM] = ttl.toString(10);
                        canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders);
                        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
                        _d = request.query;
                        _e = SIGNATURE_QUERY_PARAM;
                        _f = this.getSignature;
                        _g = [longDate,
                            scope,
                            this.getSigningKey(credentials, region, shortDate)];
                        _h = this.createCanonicalRequest;
                        _j = [request,
                            canonicalHeaders];
                        return [4 /*yield*/, getPayloadHash(originalRequest, this.sha256)];
                    case 2: return [4 /*yield*/, _f.apply(this, _g.concat([_h.apply(this, _j.concat([_k.sent()]))]))];
                    case 3:
                        _d[_e] = _k.sent();
                        return [2 /*return*/, request];
                }
            });
        });
    };
    SignatureV4.prototype.sign = function (toSign, _a) {
        if (_a === void 0) { _a = {}; }
        var _b = _a.signingDate, signingDate = _b === void 0 ? new Date() : _b, options = tslib_1.__rest(_a, ["signingDate"]);
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _c, region, credentials, unsignableHeaders;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.regionProvider(),
                            this.credentialProvider()
                        ])];
                    case 1:
                        _c = _d.sent(), region = _c[0], credentials = _c[1];
                        if (typeof toSign === "string") {
                            return [2 /*return*/, this.signString(toSign, signingDate, region, credentials)];
                        }
                        else {
                            unsignableHeaders = options.unsignableHeaders;
                            return [2 /*return*/, this.signRequest(toSign, signingDate, region, credentials, unsignableHeaders)];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    SignatureV4.prototype.signString = function (stringToSign, signingDate, region, credentials) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var shortDate, hash, _a, _b, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        shortDate = formatDate(signingDate).shortDate;
                        _b = (_a = this.sha256).bind;
                        return [4 /*yield*/, this.getSigningKey(credentials, region, shortDate)];
                    case 1:
                        hash = new (_b.apply(_a, [void 0, _d.sent()]))();
                        hash.update(stringToSign);
                        _c = toHex;
                        return [4 /*yield*/, hash.digest()];
                    case 2: return [2 /*return*/, _c.apply(void 0, [_d.sent()])];
                }
            });
        });
    };
    SignatureV4.prototype.signRequest = function (originalRequest, signingDate, region, credentials, unsignableHeaders) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var request, _a, longDate, shortDate, scope, payloadHash, canonicalHeaders, signature;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        request = prepareRequest(originalRequest);
                        _a = formatDate(signingDate), longDate = _a.longDate, shortDate = _a.shortDate;
                        scope = createScope(shortDate, region, this.service);
                        request.headers[AMZ_DATE_HEADER] = longDate;
                        if (credentials.sessionToken) {
                            request.headers[TOKEN_HEADER] = credentials.sessionToken;
                        }
                        return [4 /*yield*/, getPayloadHash(request, this.sha256)];
                    case 1:
                        payloadHash = _b.sent();
                        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
                            request.headers[SHA256_HEADER] = payloadHash;
                        }
                        canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders);
                        return [4 /*yield*/, this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate), this.createCanonicalRequest(request, canonicalHeaders, payloadHash))];
                    case 2:
                        signature = _b.sent();
                        request.headers[AUTH_HEADER] =
                            ALGORITHM_IDENTIFIER + " " +
                                ("Credential=" + credentials.accessKeyId + "/" + scope + ", ") +
                                ("SignedHeaders=" + getCanonicalHeaderList(canonicalHeaders) + ", ") +
                                ("Signature=" + signature);
                        return [2 /*return*/, request];
                }
            });
        });
    };
    SignatureV4.prototype.createCanonicalRequest = function (request, canonicalHeaders, payloadHash) {
        var sortedHeaders = Object.keys(canonicalHeaders).sort();
        return request.method + "\n" + this.getCanonicalPath(request) + "\n" + getCanonicalQuery(request) + "\n" + sortedHeaders.map(function (name) { return name + ":" + canonicalHeaders[name]; }).join("\n") + "\n\n" + sortedHeaders.join(";") + "\n" + payloadHash;
    };
    SignatureV4.prototype.createStringToSign = function (longDate, credentialScope, canonicalRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var hash, hashedRequest;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hash = new this.sha256();
                        hash.update(canonicalRequest);
                        return [4 /*yield*/, hash.digest()];
                    case 1:
                        hashedRequest = _a.sent();
                        return [2 /*return*/, ALGORITHM_IDENTIFIER + "\n" + longDate + "\n" + credentialScope + "\n" + toHex(hashedRequest)];
                }
            });
        });
    };
    SignatureV4.prototype.getCanonicalPath = function (_a) {
        var path = _a.path;
        if (this.uriEscapePath) {
            var doubleEncoded = encodeURIComponent(path.replace(/^\//, ""));
            return "/" + doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
    };
    SignatureV4.prototype.getSignature = function (longDate, credentialScope, keyPromise, canonicalRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var stringToSign, hash, _a, _b, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.createStringToSign(longDate, credentialScope, canonicalRequest)];
                    case 1:
                        stringToSign = _d.sent();
                        _b = (_a = this.sha256).bind;
                        return [4 /*yield*/, keyPromise];
                    case 2:
                        hash = new (_b.apply(_a, [void 0, _d.sent()]))();
                        hash.update(stringToSign);
                        _c = toHex;
                        return [4 /*yield*/, hash.digest()];
                    case 3: return [2 /*return*/, _c.apply(void 0, [_d.sent()])];
                }
            });
        });
    };
    SignatureV4.prototype.getSigningKey = function (credentials, region, shortDate) {
        return getSigningKey(this.sha256, credentials, shortDate, region, this.service);
    };
    return SignatureV4;
}());
export { SignatureV4 };
function formatDate(now) {
    var longDate = iso8601(now).replace(/[\-:]/g, "");
    return {
        longDate: longDate,
        shortDate: longDate.substr(0, 8)
    };
}
function getCanonicalHeaderList(headers) {
    return Object.keys(headers)
        .sort()
        .join(";");
}
function getTtl(start, expiration) {
    return Math.floor((toDate(expiration).valueOf() - toDate(start).valueOf()) / 1000);
}
//# sourceMappingURL=SignatureV4.js.map